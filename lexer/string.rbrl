%%{
#%

machine Lex;


# ------------------------------------------------------------------------------
#
# Actions
#

action EofLiteralError { raise SyntaxError, current_literal.unterminated_message }


# ------------------------------------------------------------------------------
#
# Character escaping
#

action InvalidUnicode { raise SyntaxError, 'invalid Unicode escape' }
action UntermUnicode  { raise SyntaxError, 'unterminated Unicode escape' }

unicode_digits = xdigit{1,6} >lerr(InvalidUnicode);

unicode_escape = '\\u' xdigit{4} @lerr(InvalidUnicode)
               | '\\u{' unicode_digits '}' @lerr(UntermUnicode)
;

multi_unicode_escape = '\\u' xdigit{4} @lerr(InvalidUnicode)
                     | '\\u{' unicode_digits ([\t ] @lerr(UntermUnicode) unicode_digits)* '}' @lerr(UntermUnicode)
;

char_escape = '\\' (ascii - [CMcux0-7] - c_eof);

octal_escape = '\\' odigit{1,3};

action InvalidHex { raise SyntaxError, 'invalid hex escape' }

hex_escape   = '\\x' ( xdigit{1,2} >lerr InvalidHex );



action InvalidControl { raise SyntaxError, 'Invalid escape character syntax' }

ctrl_char = '\\' ( 'c' | 'C-' );
meta_char = '\\M-';

control_prefix = ctrl_char meta_char? | meta_char ctrl_char?;

control_escape = control_prefix (
    (ascii - '\\')
  | octal_escape
  | hex_escape
  | '\\' (ascii - [CMcux0-7])
) @lerr(InvalidControl);


# ------------------------------------------------------------------------------
#
# Heredocs
#

# Heredoc existence condition:
#     ( [EXPR_BEG, EXPR_FNAME, EXPR_LABELARG, EXPR_MID].include?(@cs) )
#  || ( [EXPR_ARG, EXPR_CMDARG].include?(@cs) && ( @ts == 0 || @data[@ts - 1] =~ / \f\t\r\v/ ) )


HEREDOC_DELIMITER := |*
  c_eof => EofLiteralError;

  ^nl_eof* nl_eof => {
    if current_literal.delimiter?(current_token)
      # found delimiter => end of heredoc
      gen_string_content_token
      gen_string_end_token
      @line_jump = @te
      fexec current_literal.restore;
      pop_fcall
      fnext EXPR_END;
      fbreak;
    end

    fexec @ts;
    fgoto HEREDOC_CONTENT;
  };

*|;

HEREDOC_CONTENT := |*
  # TODO: '\\\n' - counts as not being present, if id_delimiter != "'"

  c_eof => EofLiteralError;

  '\n' => { # don't jump yet
    current_literal.line_indent = 0

    if @line_jump > @p
      # content in @te..@line_jump isn't included
      gen_string_content_token(0)
      current_literal.content_start = @line_jump
      fexec @line_jump;
    end

    fgoto HEREDOC_DELIMITER;
  };

  '\\' ^c_eof => { current_literal.commit_indent };

  '#' any_var => { gen_interpolation_tokens(token_type) };

  '#{' => {
    current_literal.commit_indent
    if current_literal.interpolates?
      gen_string_content_token
      gen_token(:tSTRING_DBEG)
      fnext EXPR_BEG;
      fbreak;
    end
  };

  ' ' => {
    if current_literal.dedents? && current_literal.line_indent >= 0
      current_literal.line_indent += 1
    end
  };

  '\t' => {
    if current_literal.dedents? && current_literal.line_indent >= 0
      w = current_literal.line_indent / tab_width + 1
      current_literal.line_indent = w * tab_width
    end
  };

  any => { current_literal.commit_indent };

*|;


# ------------------------------------------------------------------------------
#
# Strings
#


STRING_DELIMITER := |*
  c_eof => EofLiteralError;

  alnum;

  ^alnum ':' [^:] => {
    fexec @te -= 1; # hold the last char [^:]

    is_labeled = current_literal.can_label? &&
      (
        fcalled_by?(EXPR_ARG, EXPR_CMDARG, EXPR_LABELARG) ||
        ( !cond? && fcalled_by?(EXPR_BEG, EXPR_ENDFN) )
      )

    tok = current_token(ote: -1)

    unless is_labeled
      fexec @te -= 1; # hold the last char ':'
    end

    unless current_literal.delimiter?(tok)
      # not the delimiter
      fexec @ts;
      fgoto *(current_literal.words? ? WORD_CONTENT : STRING_CONTENT);
    end

    # found delimiter => end string

    pop_fcall
    gen_string_content_token

    #regexp_delim, regex_options = nil
    if current_literal.regexp?
      regexp_delim, regex_options = @ts, []
      fgoto REGEXP_END;
    end

    gen_string_end_token
    fnext *(is_labeled ? EXPR_BEG : EXPR_END);
    fbreak;
  };

  ^alnum => {
    unless current_literal.delimiter?(current_token)
      fhold;
      fgoto *(current_literal.words? ? WORD_CONTENT : STRING_CONTENT);
    end

    # found delimiter => end string

    pop_fcall
    gen_string_content_token

    #regexp_delim, regex_options = nil
    if current_literal.regexp?
      regexp_delim, regex_options = @ts, []
      fgoto REGEXP_END;
    end

    gen_string_end_token
    fnext EXPR_END;
    fbreak;
  };

*|;


WORD_CONTENT := |*
  # pass-through to take care of whitespace
  # TODO: '\\\n' - counts as '\\n'

  (space - nl)+ => {
    unless gen_string_content_token
      # ignore empty content
      current_literal.content_start = @te # cannot be before gen_string_content_token
      fgoto STRING_DELIMITER;
    end

    current_literal.content_start = @te
    gen_token(:tSPACE)
    fnext STRING_DELIMITER;
    fbreak;
  };

  #TODO: embedded heredocs
  #'\n' => {};

  any => {
    fhold;
    fgoto STRING_CONTENT;
  };

*|;


STRING_CONTENT := |*
  c_eof => EofLiteralError;

  octal_escape;
  hex_escape;
  char_escape;
  multi_unicode_escape;
  control_escape;

  '#' any_var => {
    gen_interpolation_tokens(token_type);
    fgoto STRING_DELIMITER;
  };

  '#{' => {
    if current_literal.interpolates?
      gen_string_content_token
      gen_token(:tSTRING_DBEG)
      fnext EXPR_BEG;
      fbreak;
    end
  };

  '\n' => { # don't jump yet
    if @line_jump > 0
      # content in @te..@line_jump isn't included
      gen_string_content_token
      current_literal.content_start = @line_jump
      fexec @line_jump;
    end

    fgoto STRING_DELIMITER;
  };

  any => { fgoto STRING_DELIMITER; };

*|;


REGEXP_END := |*

  'm' => { regex_options << :multi_line };
  'i' => { regex_options << :ignore_case };
  'x' => { regex_options << :extend };
  'o' => { regex_options << :once };

  ( alpha - [mixo] )+ => {
    tok = current_token
    raise SyntaxError, "unknown regexp option#{tok.length == 1 ? '' : 's'} - #{tok}"
  };

  ^alpha => {
    fexec @te -= 1;
    gen_token(:tREGEXP_END, ts: regexp_delim, options: regex_options.uniq.sort);
    fnext EXPR_END;
    fbreak;
  };

*|;


# ------------------------------------------------------------------------------
#
# Single characters (e.g.: ?a)
#


CHAR := |*
  c_eof => { raise SyntaxError, 'incomplete character syntax' };

    unicode_escape
  | octal_escape
  | hex_escape
  | char_escape
  | control_escape
  | ^c_eof
  => {
    gen_token(:tCHAR)
    fnext EXPR_END;
    fbreak;
  };

*|;

}%%
#%